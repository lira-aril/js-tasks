// Задача №1
// Каким будет результат выполнения этого кода?

// let user = {
//     name: "John",
//     go: function() {
//         alert(this.name)
//     }
// }

// (user.go)()
/* при вызове функции выходит ошибка: невожможно получить 
доступ к "user", так как пропущена символ ; после user = {...}. При таком синтаксисе 
код читается let user = {go: ... }(user.go)() и в этом случае 
вызывается функция {...} с аргументами (user.go). так как объект
user еще не определен мы получаем ошибку.

Решение
вставляем символ ; после user{...}; (user.go)()
или пишем функцию без скобок: user{...} user.go() так */



// Задача №2

// let obj, method;

// obj = {
//     go: function () { alert(this); }
// };

// 1. obj.go();
/* В этом случае метод вызывается через точку и this ссылается на объект перед точкой */

// 2. (obj.go)();
/* Здесь тоже самое. Круглые скобки (оператор группировки) тут не изменяют 
порядок выполнения операций - доступ к методу через точку в любом случае срабатывает первым */

//3. (method = obj.go)();
/* Такой вызов работает, если бы он был разделен на 2 строчки
method = obj.go;
method() */

// 4. (obj.go || obj.stop)();
/* Тут похожая ситуация на случай 3 - идет потеря значений this
Здесь мы должны помнить, что доступ к свойству(через точку или квадратные скобки) возвращает специальное 
значение ссылочного типа (Reference Type).
За исключением вызова метода, любая другая операция (подобно операции присваивания (=) или
сравнения через логические операторы(||) превращает это значение
в обычное, которое не несет информации, позволяющей установить this ) */

// Задача №3

/* Здесь функция makeUser возвращает объект.
Каким будет результат при обращении к свойству объекта ref? Почему? */
// function makeUser () {
//     return {
//         name: "John",
//         ref: this
//     };
// };

// let user = makeUser();

// alert( user.ref.name )  // Каким будет результат?
/* Здесь срабатывает пустой алерт так как через this мы обращаемся к дугим свойствам 
объекта, а в нашем случае мы не обращаемся ни к чему*/

// Задача №4

let calculator = {
    read: function (a, b) {
        this.a = Number(prompt("Введите число a:"));
        this.b = Number(prompt("Введите число b:"))   
    },
    sum: function (a, b) {
        return this.a + this.b
    },
    mul: function (a, b) {
        return this.a * this.b
    }
};

calculator.read();
alert( calculator.sum());
alert( calculator.mul());

// Задача №5

// let ladder = {
//     step: 0,
//     up() {
//         this.step ++;
//         return this;
//     },
//     down() {
//         this.step --;
//         return this;
//     },
//     showStep() {
//         alert(this.step);
//         return this
//     }
// }

// ladder
//    .up()
//    .up()
//    .down()
//    .up()
//    .up()
//    .down()
//    .showStep();
